Part 1 COBOL language structure 1
Chapter 1 Characters 3
Chapter 2 Character sets and code pages 7
Character encoding units 7
Chapter 3 Character-strings: COBOL words and literals 11
COBOL words with single-byte characters 11
User-defined words with DBCS characters 12
User-defined words12
System-names13
Function-names 14
Reserved words14
Figurative constants 15
Special registers 17
ADDRESS OF 18
DEBUG-ITEM19
JNIENVPTR 20
JSON-CODE20
JSON-STATUS 21
LENGTH OF21
LINAGE-COUNTER22
RETURN-CODE23
SHIFT-OUT and SHIFT-IN 23
SORT-CONTROL 24
SORT-CORE-SIZE24
SORT-FILE-SIZE25
SORT-MESSAGE 25
SORT-MODE-SIZE 26
SORT-RETURN 26
TALLY 26
WHEN-COMPILED27
XML-CODE27
iii
XML-EVENT 28
XML-INFORMATION33
XML-NAMESPACE 33
XML-NNAMESPACE34
XML-NAMESPACE-PREFIX 35
XML-NNAMESPACE-PREFIX35
XML-NTEXT 36
XML-TEXT 36
Literals 37
Alphanumeric literals37
DBCS literals 40
UTF-8 literals 42
Numeric literals44
National literals45
PICTURE character-strings 47
Comments 47
Chapter 4 Separators49
Rules for separators 50
Chapter 5 Sections and paragraphs 53
Sentences, statements, and entries 53
Entries 54
Clauses54
Sentences54
Statements54
Phrases54
Chapter 6 Reference format 55
Sequence number area 55
Indicator area 55
Area A 55
Division headers56
Section headers 56
Paragraph headers or paragraph names56
Level indicators (FD and SD) or level-numbers (01 and 77)57
DECLARATIVES and END DECLARATIVES 57
End program, end class, and end method markers 57
Area B 57
Entries, sentences, statements, clauses57
Continuation lines 58
Area A or Area B 59
Level-numbers 60
Comment lines 60
Floating comment indicators (*>)60
Compiler-directing statements 61
Compiler directives 61
Debugging lines61
Pseudo-text61
Blank lines61
Chapter 7 Scope of names63
Types of names63
External and internal resources65
Resolution of names66
Chapter 8 Referencing data names, copy libraries, and PROCEDURE DIVISION names67
Uniqueness of reference 67
iv
Qualification 67
Identical names 68
References to COPY libraries68
References to PROCEDURE DIVISION names68
References to DATA DIVISION names 69
Condition-name 71
Index-name71
Index data item72
Subscripting 72
Reference modification75
Function-identifier 77
Data attribute specification78
Chapter 9 Transfer of control79
Part 2 COBOL source unit structure 81
Chapter 10 COBOL program structure 83
Nested programs85
Conventions for program-names86
Chapter 11 COBOL class definition structure 89
Chapter 12 COBOL method definition structure93
Part 3 IDENTIFICATION DIVISION95
Chapter 13 IDENTIFICATION DIVISION 97
PROGRAM-ID paragraph97
CLASS-ID paragraph 100
General rules101
Inheritance 102
FACTORY paragraph102
OBJECT paragraph 102
METHOD-ID paragraph 102
Optional paragraphs104
Part 4 ENVIRONMENT DIVISION107
Chapter 14 Configuration section 109
SOURCE-COMPUTER paragraph110
OBJECT-COMPUTER paragraph110
SPECIAL-NAMES paragraph 112
ALPHABET clause115
CLASS clause117
CURRENCY SIGN clause 117
DECIMAL-POINT IS COMMA clause 119
SYMBOLIC CHARACTERS clause119
XML-SCHEMA clause119
REPOSITORY paragraph 120
General rules122
Identifying and referencing a class 122
Chapter 15 Input-Output section125
FILE-CONTROL paragraph 126
SELECT clause130
ASSIGN clause 130
v
RESERVE clause 134
ORGANIZATION clause134
File organization 134
PADDING CHARACTER clause 136
RECORD DELIMITER clause136
ACCESS MODE clause 136
File organization and access modes 138
Access modes 138
Relationship between data organizations and access modes 138
RECORD KEY clause 139
ALTERNATE RECORD KEY clause140
RELATIVE KEY clause141
PASSWORD clause 141
FILE STATUS clause 142
I-O-CONTROL paragraph 143
RERUN clause144
SAME AREA clause145
SAME RECORD AREA clause146
SAME SORT AREA clause146
SAME SORT-MERGE AREA clause 147
MULTIPLE FILE TAPE clause147
APPLY WRITE-ONLY clause 147
Part 5 DATA DIVISION 149
Chapter 16 DATA DIVISION overview151
FILE SECTION 153
WORKING-STORAGE SECTION 153
LOCAL-STORAGE SECTION154
LINKAGE SECTION155
Data units 155
File data 155
Program data 156
Method data156
Factory data 156
Instance data156
Data relationships 156
Levels of data156
Levels of data in a record description entry157
Special level-numbers159
Indentation 159
Classes and categories of group items 159
Classes and categories of data160
Category descriptions162
Alignment rules164
Character-string and item size 165
Signed data 166
Dynamic-length items 166
Chapter 17 DATA DIVISION--file description entries169
FILE SECTION 174
EXTERNAL clause174
GLOBAL clause 175
BLOCK CONTAINS clause 175
RECORD clause 176
Format 1176
Format 2177
vi
Format 3177
LABEL RECORDS clause178
VALUE OF clause 179
DATA RECORDS clause179
LINAGE clause179
LINAGE-COUNTER special register180
RECORDING MODE clause181
CODE-SET clause 182
Chapter 18 DATA DIVISION--data description entry 183
Format 1 183
Format 2 183
Format 3 184
Level-numbers 184
BLANK WHEN ZERO clause 185
DYNAMIC LENGTH clause185
EXTERNAL clause187
GLOBAL clause 187
JUSTIFIED clause 188
GROUP-USAGE clause 188
OCCURS clause 190
Fixed-length tables191
ASCENDING KEY and DESCENDING KEY phrases 191
INDEXED BY phrase 192
Variable-length tables 194
OCCURS DEPENDING ON clause 195
PICTURE clause 197
Symbols used in the PICTURE clause198
Character-string representation202
Data categories and PICTURE rules202
PICTURE clause editing209
Simple insertion editing210
Special insertion editing 211
Fixed insertion editing 211
Floating insertion editing212
Zero suppression and replacement editing 214
REDEFINES clause 215
REDEFINES clause considerations 217
REDEFINES clause examples217
Undefined results 218
RENAMES clause218
SIGN clause220
SYNCHRONIZED clause 221
Slack bytes223
Slack bytes within records 223
Slack bytes between records 225
USAGE clause227
Computational items 228
DISPLAY phrase230
DISPLAY-1 phrase 230
FUNCTION-POINTER phrase 231
INDEX phrase 231
NATIONAL phrase231
OBJECT REFERENCE phrase232
POINTER phrase232
POINTER-32 phrase 233
PROCEDURE-POINTER phrase 234
NATIVE phrase235
vii
UTF-8 phrase 235
VALUE clause235
Format 1235
Format 2238
Format 3241
VOLATILE clause 242
Part 6 PROCEDURE DIVISION 245
Chapter 19 Procedure division structure 247
Requirements for a method procedure division248
The PROCEDURE DIVISION header 248
The USING phrase 249
RETURNING phrase250
References to items in the LINKAGE SECTION 251
Declaratives251
Procedures 252
Arithmetic expressions 253
Arithmetic operators 254
Conditional expressions255
Simple conditions 255
Class condition256
Condition-name condition258
Relation conditions 259
General relation conditions 259
Data pointer relation conditions267
Procedure-pointer and function-pointer relation conditions268
Object-reference relation conditions 269
Sign condition 270
Switch-status condition270
Complex conditions 270
Negated simple conditions271
Combined conditions272
Abbreviated combined relation conditions274
Statement categories277
Imperative statements277
Conditional statements 279
Delimited scope statements 280
Explicit scope terminators280
Implicit scope terminators 281
Compiler-directing statements 281
Statement operations 281
CORRESPONDING phrase 282
GIVING phrase283
ROUNDED phrase 283
SIZE ERROR phrases 283
Arithmetic statements284
Arithmetic statement operands 284
Data manipulation statements286
Input-output statements286
Common processing facilities 286
Chapter 20 PROCEDURE DIVISION statements 293
ACCEPT statement 293
Data transfer 293
System date-related information transfer 295
DATE, DATE YYYYMMDD, DAY, DAY YYYYDDD, DAY-OF-WEEK, and TIME 295
viii
Example of the ACCEPT statement 297
ADD statement 297
ALLOCATE statement 299
Example: ALLOCATE and FREE storage for UNBOUNDED tables301
ALTER statement303
Segmentation considerations 304
CALL statement 304
CANCEL statement310
CLOSE statement 311
Effect of CLOSE statement on file types 312
COMPUTE statement314
CONTINUE statement 315
DELETE statement 316
DISPLAY statement317
DIVIDE statement 319
ENTRY statement 322
EVALUATE statement 323
Determining values325
Comparing selection subjects and objects 326
Executing the EVALUATE statement 326
EXIT statement 326
Format 1 (simple) 327
Format 2 (program) 327
Format 3 (method)327
Format 5 (inline-perform)328
Format 6 (procedure) 328
FREE statement329
GOBACK statement329
GO TO statement330
Unconditional GO TO 330
Conditional GO TO 331
Altered GO TO 331
IF statement332
Transferring control 332
Nested IF statements333
INITIALIZE statement 334
INITIALIZE statement rules336
INSPECT statement 337
Data flow 344
Comparison cycle 344
Example of the INSPECT statement 345
INVOKE statement 346
Interoperable data types for COBOL and Java 350
Miscellaneous argument types for COBOL and Java 352
JSON GENERATE statement 353
Nested JSON GENERATE or JSON PARSE statements359
Operation of JSON GENERATE 359
Format conversion of elementary data 360
Trimming of generated JSON data 361
JSON name formation 361
JSON PARSE statement 362
Nested JSON GENERATE or JSON PARSE statements367
Operation of JSON PARSE 367
Examples of matched and mismatched data definitions and JSON text368
Count of table elements set by JSON PARSE 369
Valid and invalid elementary moves 369
MERGE statement 370
MERGE special registers374
ix
Segmentation considerations 375
MOVE statement 375
Elementary moves 376
Moves involving file record areas 380
Group moves380
MULTIPLY statement381
OPEN statement383
General rules385
OPEN statement notes 385
PERFORM statement387
Basic PERFORM statement 388
PERFORM with TIMES phrase 392
PERFORM with UNTIL phrase 392
PERFORM with VARYING phrase 393
READ statement 399
Processing files with variable-length records or multiple record descriptions 401
Sequential access mode401
Random access mode 403
Dynamic access mode 404
READ statement notes 404
RELEASE statement 404
RETURN statement 405
REWRITE statement407
Reusing a logical record 408
Sequential files 408
Indexed files 408
Relative files409
SEARCH statement 409
Serial search 411
Binary search 413
Search statement considerations 415
SET statement 415
Format 1: SET for basic table handling 416
Format 2: SET for adjusting indexes 417
Format 3: SET for external switches 417
Format 4: SET for condition-names 418
Format 5: SET for USAGE IS POINTER data items 418
Format 6: SET for procedure-pointer and function-pointer data items419
Format 7: SET for USAGE OBJECT REFERENCE data items421
Format 8: SET for length of dynamic-length elementary items 421
SORT statement 422
SORT special registers429
Segmentation considerations 429
START statement430
Indexed files 431
Relative files431
STOP statement 432
STRING statement 432
Data flow 435
Example of the STRING statement 436
SUBTRACT statement 437
UNSTRING statement 439
Data flow 443
Values at the end of execution of the UNSTRING statement444
Example of the UNSTRING statement 445
WRITE statement 445
WRITE for sequential files450
WRITE for indexed files 452
x
WRITE for relative files452
XML GENERATE statement 453
Nested XML GENERATE or XML PARSE statements 460
Operation of XML GENERATE 460
Format conversion of elementary data 461
Trimming of generated XML data 462
XML element name and attribute name formation462
XML PARSE statement 463
Nested XML GENERATE or XML PARSE statements 467
Control flow467
Part 7 Intrinsic functions 469
Chapter 21 Intrinsic functions 471
Specifying a function471
Function definition and evaluation472
Types of functions472
Rules for usage 473
Arguments474
Examples 475
ALL subscripting 476
Format of arguments and return values for date and time intrinsic functions 477
Function definitions481
ABS 488
ACOS488
ANNUITY 488
ASIN489
ATAN 489
BIT-OF 489
BIT-TO-CHAR 490
BYTE-LENGTH 490
CHAR491
COMBINED-DATETIME 492
COS 492
CURRENT-DATE493
DATE-OF-INTEGER 494
DATE-TO-YYYYMMDD 494
DAY-OF-INTEGER495
DAY-TO-YYYYDDD 495
DISPLAY-OF496
E 497
EXP 498
EXP10 498
FACTORIAL 498
FORMATTED-CURRENT-DATE 499
FORMATTED-DATE499
FORMATTED-DATETIME 500
FORMATTED-TIME 502
HEX-OF 503
HEX-TO-CHAR 503
INTEGER504
INTEGER-OF-DATE 504
INTEGER-OF-DAY 505
INTEGER-OF-FORMATTED-DATE505
INTEGER-PART506
LENGTH 506
LOG 508
xi
LOG10508
LOWER-CASE508
MAX509
MEAN 510
MEDIAN 510
MIDRANGE 510
MIN 511
MOD 511
NATIONAL-OF 512
NUMVAL513
NUMVAL-C 514
NUMVAL-F 515
ORD516
ORD-MAX517
ORD-MIN 517
PI 518
PRESENT-VALUE 518
RANDOM518
RANGE 519
REM519
REVERSE520
SECONDS-FROM-FORMATTED-TIME521
SECONDS-PAST-MIDNIGHT 521
SIGN 522
SIN522
SQRT 523
STANDARD-DEVIATION 523
SUM523
TAN 524
TEST-DATE-YYYYMMDD524
TEST-DAY-YYYYDDD 525
TEST-FORMATTED-DATETIME 526
TEST-NUMVAL 526
TEST-NUMVAL-C 527
TEST-NUMVAL-F529
TRIM 530
ULENGTH 530
UPOS531
UPPER-CASE 533
USUBSTR 534
USUPPLEMENTARY 535
UUID4 536
UVALID 537
UWIDTH539
VARIANCE 540
WHEN-COMPILED 541
YEAR-TO-YYYY 542
Part 8 Compiler-directing statements and compiler directives 543
Chapter 22 Compiler-directing statements 545
BASIS statement545
PROCESS(CBL) statement546
*CONTROL (*CBL) statement 546
Source code listing 547
Object code listing 547
Storage map listing 547
xii
COPY statement 548
Comparison and replacement rules551
Comparison and replacement examples 553
Copy member search order557
DELETE statement 557
EJECT statement558
ENTER statement 558
INSERT statement559
READY or RESET TRACE statement559
REPLACE statement 560
Comparison rules562
Replacement rules562
SERVICE LABEL statement 563
SERVICE RELOAD statement 564
SKIP statements 564
TITLE statement564
USE statement565
EXCEPTION/ERROR declarative565
Precedence rules for nested programs567
DEBUGGING declarative 567
Chapter 23 Compiler directives569
CALLINTERFACE569
DATA 570
INLINE 570
Conditional compilation 572
DEFINE573
EVALUATE574
IF 576
Examples of conditional compilation577
Constant conditional expressions 578
Compile-time arithmetic expressions579
Predefined compilation variables 580